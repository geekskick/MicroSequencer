-- Code your testbench here
library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

entity top_model is
    port( 
        -- ins
		  z, clk  	: in std_logic;
        IR      	: in std_logic_vector(3 downto 0);
       
		  -- outs
		  error, ARLOAD, ARINC, R, W, MEMBUS, BUSMEM, PCINC, PCLOAD, PCBUS, DRLBUS, DRHBUS, DRLOAD, TRLOAD, TRBUS, IRLOAD, RLOAD, RBUS, ACLOAD, ACBUS, ZLOAD	: out std_logic;
        
		  ALUSELECT : 	out std_logic_vector(3 downto 0);
		  
		  --segment displayers
		  curr_add_H: out std_logic_vector(6 downto 0);
		  curr_add_L: out std_logic_vector(6 downto 0)
    );
end entity;

architecture b of top_model is

    signal m3           : std_logic;
    signal m1           : std_logic_vector(3 downto 0);
    signal m2           : std_logic_vector(2 downto 0);
	 
	 signal curr_add		: std_logic_vector(5 downto 0);
	 
	 signal m1_int			: unsigned (3 downto 0);

    -- microoperations
    signal nop1, nop2, nop3, arin, ardt, arpc, acin, aczo, acr, acdr, minu, plus, aand, oor, xxor, nnot, trdr, pcin, pcdt, irdr, rac, mdr, drac, zalu, drm:std_logic;
    
    component microsequencer is
    port(
        clk, z             : in std_logic;
        instruction        : in std_logic_vector(3 downto 0);
        current_addr_out   : out std_logic_vector(5 downto 0);
        m1                 : out std_logic_vector(3 downto 0);
        m2                 : out std_logic_vector(2 downto 0);
        m3                 : out std_logic
    );
    end component microsequencer;
    
    component four_bit_decoder is
    port(
        input   : in std_logic_vector(3 downto 0);
        O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15 : out std_logic
    );
    end component four_bit_decoder;

    component three_bit_decoder is
    port(
        input   : in std_logic_vector(2 downto 0);
        O0, O1, O2, O3, O4, O5, O6, O7 : out std_logic
    );
    end component three_bit_decoder;
    
    component one_bit_decoder is
    port(input: in std_logic;
         O0, O1: out std_logic
         );
    end component one_bit_decoder;
	 
	component seg is
	port(
		Inumber: in std_logic_vector(3 downto 0);
		ODisp: out std_logic_vector(6 downto 0)
	);
	end component seg;
    
begin

	m1_int <= unsigned(m1);

	HDigit 	: seg port map(("00" & curr_add(5 downto 4)), curr_add_H); 
	LDigit 	: seg port map( curr_add(3 downto 0), curr_add_L);

    m1_ops   : four_bit_decoder port map(m1, nop1, arin, ardt, arpc, acin, aczo, acr, acdr, minu, plus, aand, oor, xxor, nnot, trdr, error);
    
    m2_ops   : three_bit_decoder port map(m2, nop2, pcin, pcdt, irdr, rac, mdr, drac, zalu);
    
    m3_ops   : one_bit_decoder port map(m3, nop3, drm);
    
    mseq    : microsequencer port map(clk, z, IR, curr_add, m1, m2, m3);
    
	 ARLOAD <= arpc or ardt;
	 ARINC <= arin;
	 R <= drm;
	 W <= mdr;
	 MEMBUS <= drm;
	 BUSMEM <= mdr;
	 PCINC <= pcin;
	 PCLOAD <= pcdt;
	 PCBUS <= arpc;
	 DRLBUS <= acdr or mdr;
	 DRHBUS <= pcdt or ardt;
	 DRLOAD <= drm or drac;
	 TRLOAD <= trdr;
	 TRBUS <= ardt or pcdt;
	 IRLOAD <= irdr;
	 RLOAD <= rac;
	 RBUS <= acr or aand or oor or xxor;
	 ACLOAD <= acdr or acr or plus or minu or acin or aczo or aand or oor or xxor or nnot;
	 ACBUS <= drac or rac;
	 ZLOAD <= zalu;
	 
	 process(m1)
	 begin
	 case m1 is
		when "0100"|"0101"|"0110"|"0111"|"1000"|"1001"|"1010"|"1011"|"1100"|"1101"|"1110" => ALUSELECT <= std_logic_vector(unsigned(m1) - 3);
		when others => ALUSELECT <= "0000";
	 end case;
	 end process;
    
end architecture;


