# Tests

These are test benches and they prove that your VHDL modules work. In this directory I have an `all` testbench and it brings all the testbenches together to run them. There are also the separate test benches for testing the modules on their own if you want.

## Ways of Testing

There are loads of ways of testing but there are 4 main ones to consider.
1. Not testing and hoping for the best.
2. Using a simulator such as Modelsim to look at the wiggly lines, and **forcing** values to see the changes. This is relatively easy to do but it's very time consuming if you have lots of functionality or want to run a test more than once.
3. A `.tcl` script. `.tcl` (pronounced tickle!) stands for **t**ool **c**command **l**anguage and it's v powerful if used right. Often these are [less portable](https://groups.google.com/forum/#!topic/comp.lang.vhdl/gPYmE7sTB98) because of different tools you can use. It's also another language to learn/get to grips with. Since I don't know which tool you're using to create your CPU I have decided not to go with this option. 
4. A testbench. These can be written in vhdl and since they use VHDL most tools should be able to compile and run them. It can be abit dounting at first but using something like tickle or a testbench means that you can run a test as many times as you want in a very short space of time. This, or tickle, is the method which I suggest you use for the testing of you individual modules and the CPU itself.

## Testbench Anatomy

Using the [nor testbench](nor_testbench.vhd) as the example. The testbench itself has no interfaces with the outside world so the `entity` is empty:

```vhdl
entity nor_testbench is
end nor_testbench;
```

Inside the testbench we will need an instance of the unit under test (UUT) so we declare this item. This part is copy and pasted from the nor_vector.vhd source file:

```vhdl
    component nor_vector is
        generic(
            v_width : natural
        );
        port(
            d : in  std_logic_vector(v_width-1 downto 0);
            q : out std_logic
        );
    end component;
```

___
One thing not used but I have left it in as part of my boilerplate code is the clock! This is a signal generated by the testbench which would typically go into the UUT. The clock is made using these things:

```vhdl
    constant period : time    := 200ns;
    signal clk      : std_logic;
    signal stop     : boolean := false;
    
begin
    clk_tick : process
    begin
        while stop = false loop
            clk <= '1';
            wait for period/2;
            clk <= '0';
            wait for period/2;
        end loop;
        wait;
    end process;
```
    
There is a `constant` called `period` which is a passage of `time`:

```vhdl
constant period : time    := 200ns;
```

There is a wire which actually has that square wave on:

```vhdl
signal clk      : std_logic;
```

And there is a signal which goes high when we need to stop ticking:
```vhdl
signal stop     : boolean := false;
```

Then finally the process itself. Remember that stuff in hardware happens concurrently (at the same time), apart from stuff in a process which happens sequentially (one after the other). So to have a squarewave happening at the same time as our UUT testing we need a `process`. This process simply waits for half of the clock period and sets the `clk` wire to the needed value, until the `stop` wire goes high. 
    
```vhdl
    clk_tick : process
    begin
        while stop = false loop
            clk <= '1';
            wait for period/2;
            clk <= '0';
            wait for period/2;
        end loop;
        wait;
    end process;
```
___
Finally there is the process which tests the UUT itself. This is where knowing the requirements (expected behaviour) for your module are super important as they drive this process. So to recap the requirements of the `nor_vector`:
> When all of the inputs to the module are `0` the output shall be `1`.

> When any of the inputs to the module is `1` the output shall be `0`.

So the test in this case is to set each input to `1` in turn (using a [for loop](https://www.ics.uci.edu/~jmoorkan/vhdlref/for_loop.html) and check that the output is still `0`. Then to set them all to `0` and check that the output is in fact `1`. This is where the `report` statement comes in useful:

```vhdl
assert q = '0' report "Q isn't 0 when " & integer'image(i) & " : " & std_logic'image(q); 
```

[Here `assert` means to check that `q ='0'` is `true`, otherwise `report` the message "Q isn't 0 when xxx : 1". If `q` is `0` then nothing will be output to the screen!](https://www.ics.uci.edu/~jmoorkan/vhdlref/assert.html)

Finally when all the testing is done the `stop` signal needs to be set to make sure that the clock ticking stops! I also find it's useful to output a message to say that the test is done as well.

## Gotchas

All of my testbenches use VHDL 2008 so that I can use the `integer'image(i) & " : " & std_logic'image(q)` functionality to convert the signals to strings to print them off. So in your tool make sure that you set the test bench file proporties to _VHDL 2008_ instead of just _VHDL_.
